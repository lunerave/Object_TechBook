# Object_Chapter 1: 티켓 판매 애플리케이션 구현하기

## 애플리케이션 요구 사항
  1. 이벤트에 당첨된 손님에게는 초대장을 발송, 초대장이 있는 손님은 초대장을 티켓으로 교환하여 극장 입장 가능
  
  2. 초대장이 없는 손님은 티켓을 구매해서 입장 가능


## 초기 구현 모델: 초대장, 티켓, 가방, 관람객, 매표소, 매표소 직원, 극장
* 초대장 : 이벤트에 당첨된 손님에게 발송된 초대장
* 티켓 : 입장하기 위해서 필요한 Ticket
* 가방 : 손님이 가방에 가지고 오는 물품들은 초대장(invitation), 티켓(ticket), 현금(amount)
  * 손님이 가지고 있는 가방에는 두 가지 경우의 수가 있다.
    * 초대장이 있고, 현금이 있다.(현금의 양은 상관없는 case)
    * 초대장이 없고, 현금이 있다.(현금의 양이 중요한 case)
  * Bag 생성자에 위 두 가지 경우의 수를 강제하는 제약을 걸어둔다.
* 관람객 : 관람객은 가방을 소지하고 있다.
* 매표소 : 매표소에는 티켓과 수익 현금을 보유하고 있다.
* 매표소 직원 : 매표소 직원은 매표소에 소속되어 있다.
* 극장 : 손님의 가방 안에 초대장이 있는지 없는지 판단한다.
  * 가방 안에 초대장이 있다면, 초대장을 티켓으로 교환한다. -> 극장 이익x, 손님 현금 지출x
  * 가방 안에 초대장이 없다면, 현금으로 티켓을 구매한다. -> 극장 이익ㅇ, 손님 현금 지출ㅇ

## 로버트 마틴(Robert C. Martin)이 말한 소프트웨어 모듈이 가져야 하는 세 가지 기능
* 제대로 실행되어야 한다.
* 변경이 용이해야 한다.
* 이해하기 쉬워야 한다.

## 초기 구현 모델의 문제점
1. **예상을 빗나가는 코드** : 초기 프로그램에서는 극장이 관람객과 판매원의 작업을 통제한다. 하지만, 실제 상황에서는 그렇지 않다.
  
   이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드이다. 따라서, 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건네고, 판매원이
   직접 매표소에 있는 티켓을 직접 꺼내 고나람객에게 건네는 것이 현실적으로 이해 가능한 코드이다.

2. **변경에 취약한 코드** : 초기 프로그램은 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정한다.

   만약, 이러한 가정이 바뀌는 상황을 직면한다면 어떻게 해야 할까?

   가정이 깨지는 순간 모든 코드가 한번에 흔들리게 된다.
   객체 지향 설계는 서로 의존하면서 객체들의 공동체를 구축하는 것. 따라서, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하는 게 목표이다.

## 의존성과 캡슐화
1. **의존성** : 한 클래스에서 문제가 생겨 변경되어야 할 때, 그와 연관된 다른 클래스의 코드까지 변경되어야 할 때. 이것을 의존성이라고 말함.
2. **캡슐화** : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 한다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 캡슐화를 통해서 객체를 자율적인 존재로 만들 수 있다.

  

  

     
